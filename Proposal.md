## Leading Question: Your final project should have a clear conclusion or target goal – given a dataset and a code base that implements some graph algorithms, what can you learn from the dataset? Are you hoping to solve a specific problem? Are you hoping to produce a general search tool? Make sure that your entire team is on the same page for what a ‘successful’ project will look like. Be sure that your motivating question is solvable or your proposed final deliverable is reasonable as you will be expected to accomplish it.
* Through our project, we will visualize the relations between songs and their characteristics through a data graph. We will use a dataset of songs (https://www.kaggle.com/mrmorj/dataset-of-songs-in-spotify)  with characteristics given by the Spotify API that have been compiled into a static dataset. The final graph will plot points at various distances from each other based on a mathematical equation we create that accounts for the various characteristics of each song including energy, key, danceability, and other auditory features. For our group, a successful project will be to analyze any dataset similar to the one we are working with and plot all of the songs in relation to each other based on similarity between various songs equating to the visual distance in the visual representation of our analysis. We want to allow users to select one song from a dataset and build a visualization graph around that song determining how every other song in that dataset relates to that song based on all of the features. If we have more time, we would also like to allow users to filter by which feature they focus on and have various metrics for distance based on the user’s selection on what feature they want the basis of analysis to be.
## Dataset Acquisition and Processing: Your final project must use at least one publicly accessible dataset and your proposal must clearly describe what dataset you have chosen to use. As part of this description, you must state how you will download, store, and process your data. This includes succinctly describing the data format and clearly identifying how said data will be used in your proposed graph data structures. Be advised that real world data is often messy and your proposed datasets may have errors or missing entries. Your proposal should also briefly describe how your group will handle these potential errors.
* We have chosen this dataset: https://www.kaggle.com/mrmorj/dataset-of-songs-in-spotify. This includes various features for analysis including loudness, mode, danceability, energy, key and more. We will download the dataset from Kaggle into our project. The dataset is a CSV file and we will process the data using a C++ library to process our data and convert it into a usable JSON. From there, we will use OOP principles to deserialize this data into classes in a manner where it is easy for us to analyze and group various features of the data.  Each song’s characteristics will be put into the equation we create that was mentioned in the previous answer. For missing values or are erroneous, we will substitute the average value of all the other entries in order to avoid skewed data or use a standardized median or baseline value that we will find through research on the auditory features of songs in general. 
## Graph Algorithms: Your final project must implement at least two graph data algorithms as well as a graph traversal from the list of example goals or you must propose an algorithm or set of graph algorithms that represent an equivalent amount of coding development. Accordingly, your proposal should clearly state what algorithms you will complete by the projects end. When describing your choices, be sure to include the following: What are the inputs you expect each method to take in? What output are you expecting for each method? If there are multiple ways to implement an algorithm, what is your target big O or efficiency benchmark? For the more complex algorithms, be sure to include as part of the input any additional information you might need. For example, A* search requires a heuristic. If you choose to do A*, what are some possible heuristics you might use?
* We will be implementing the shortest path Dijkstra algorithm to find similar songs using a graph structure.	
  * Our graph will consist of all the songs in our dataset. These songs will be the nodes. Each song has values for each field assigned to them (i.e. a value for danceability, value for energy) given by the dataset. These values will be averaged to assign a mean value for each category. These average values will then be compiled to create the “average song.”
    * Every song in our dataset will have a score that is determined by an equation that compares them to our “average song.”
      * Song Score = sqrt[weight1(average_song_feature_value1 - song_feature_value1) + weight2(average_song_feature_value2 - song_feature_value2). . . + weightN(average_song_feature_valueN - song_feature_valueN)]
        * We may remove the weights if we feel it overcomplicates things; however, at the moment, we believe that certain categories make songs more similar than others (i.e. key can be the same for a pop song and a country song, but perhaps liveliness is a better differentiating factor)
    * We will then determine a threshold, which the difference between song scores must be below: abs(song2_score - song1_score < threshold). When the scores of two songs meet this threshold, then they are connected by an edge.
      * This threshold will be determined by x standard deviations away from the mean song. x will be decided by picking a threshold which connects some but not all songs.
      * This will give us our connected components, which we can then later analyze to find the largest group of similar songs.
  * Our method will take in two nodes that each represent a song, and then output the shortest path between those two songs. We hope for the time complexity to be O(E*logV) where V is the number of vertices and E is the number of edges. This will tell the user the sequence of songs that are most similar in relation and how they morph or transition into each other. In some cases, there will not be a path from one song to another, meaning that they are simply too different to be connected to each other.
* We will be using the Floyd cycle detection algorithm in our graph to find groupings of similar songs as all the songs would relate to each other in one way or another.
  * Our method will take in a graph of all of the nodes in relation to the selected song and output groupings of similarities based on the cycles that it finds. If there are a lot of cycles, then we can make it more selective and only output cycles given a lower bound on size. In other words, we can choose to only return the largest group of similar songs.
* For traversals, we hope to implement a BFS traversal given a starting point as this would give us a list of the songs ordered from most similar to least similar to the user’s selected song.  
## Timeline: As a team, identify a list of tasks such as data acquisition, data processing, completion of each individual algorithm, production of final deliverables, etc… and write a proposed timeline for the completion of these tasks. You are not required to adhere strictly to this timeline but it should represent a reasonable set of benchmarks to strive for. For example, stating that you will finish all graph algorithms over the span of a single week is not reasonable. You will be expected to accomplish at least some of these tasks by the mid-project checkin.
* Week of 11/7: Start data processing & choose a library for visualization
* Week of 11/14: Finish data processing & plan out project structure & algorithm approaches, code out the OOP classes for deserialization and use libraries to parse and format data
* Week of 11/21: Graph Algorithm I & II - break into pairs of 2 for each algorithm
* Week of 11/28: Graph Algorithm I & II - optimize algorithms and test edge cases 
* Week of 12/5: Graph Algorithm I & II - Build out visualization and refactor code to be clean. If time permits, build UI to interact with users as well 
* 12/13: DUE DATE
